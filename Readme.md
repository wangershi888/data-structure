# 常用数据结构

## 栈

### 概念

    栈是一种后进先出的数据结构

### 栈的操作

- push: 入栈
- pop: 出栈
- peek: 检查栈顶元素
- isEmpty: 是否为空
- clear: 清空栈
- size: 栈中元素个数

## 队列

### 概念

    队列是一种先进先出的数据结构

### 队列的操作

- enqueue: 入队
- dequeue: 出队
- front: 查看队列头
- isEmpty: 是否为空
- size: 队列长度

### 循环队列

### 优先队列

    需要考虑优先级，相当于入列的时候，根据优先级插入道合适的位置

## 链表

    一个元素存在指向自身前一个元素以及指向自身后一个元素的地址的结构

### 操作

- insert: 插入元素，指定位置，以及元素
- append: 尾部添加元素，指定元素
- indexOf: 获取元素索引，指定元素
- remove: 移除元素，指定元素
- removeAt: 从特定位置移除某一项，指定位置

### 双向列表

    每个链表会同时记录下一个和上一个(previous)的位置

### 双向循环列表

    不仅仅同时存储previous、next,最后一个节点的next指向自己的head

## 集合

    1、集合中不能有重复元素
    2、空集：没有任何元素的集合叫空集
    3、子集：A中所有的元素再B中都有，则可以称 A 是 B 的子集

    Set :
    方法：
    + add： 添加元素
    + clear: 清空集合
    + delete: 删除元素
    + entire: 迭代器
    + forEach: 遍历方法
    + has: 检查元素是否存在
    + size: 获取集合大小
    + values: 获取全部值

    weakSet:

    + add: 添加元素
    + delete: 删除元素
    + has: 检查元素

    Set 和 weakSet的区别：
    1、weakSet方法较少、set方法丰富
    2、weakSet只能添加Object类型的数值
    3、Set是强引用、weakSet为弱引用（JS内存回收机制）
        ```
        let obj = {a: 'a'}
        obj = null
        // 之前的 {a: 'a'}失去引用后，会被CG内存回收掉

        强引用：
        let obj = {a: 'a'}
        let a = new Set(obj)
        obj = null
        // 此时 {a: 'a'} 的值仍然会存在（强引用）如果使用weakSet的话会被清理掉
        ```

## 字典

概念：key-value

## 散列表（哈希表）

概念：通过唯一 id 去访问对应数据，进行快速定位，否则循环遍历性能开销较大[{a: 'a'}, {a:'b'}]
散列函数：计算这个唯一 id 的方法，通过 key,经过散列函数，计算出散列值，直接在散列表中进行查询
常用散列函数：
1、losehasecode(常用生成哈希码的散列函数)
2、djb2HashCode(更强大一些，因为使用它降低了冲突问题，减少了因为解决冲突而造成的性能浪费)

问题：
1、散列冲突：可能会存在覆盖问题，计算出来的散列值一样的情况下，后边的会覆盖前边的
解决方法：
1、分离连接法：冲突 hash 表的每项存储一个链表，相当于重新创建了一个空间
2、线性探查法：如果当前项已经存在，那么往后顺延，实现相对来说比较简单

## 树

### 二叉搜索树：

#### 优点：

- 查找非常快速

#### 特点：

- 每个节点只有两个子节点
- 每个节点的左侧子节点，小于父节点，右侧子节点大于父节点

#### 遍历方式

- 先序遍历
- 中序遍历
- 后序遍历

#### 移除节点的方式

原理是重新构建树

- 移除叶节点：直接移除
- 移除只有一个子节点的节点：只需要将其子节点替换到当前位置即可
- 移除有两个子节点的节点：替换为右侧子树的最小节点（数学推导出来的）

## 图

### 概念

- 有向图：图和图之间的连接可能是单向的，也有可能是双向的。有向图的节点之间有方向

- 无向图：节点之间没有方向

### 图的表示方式

- 邻接矩阵：使用二维矩阵表示节点之间的关系，相连用 1 表示，否则用 0 表示

- 缺点：

  - 非常浪费计算机内存
  - 添加、删除节点非常麻烦

- 邻接表：记录对应节点所连接的节点
  - vertices: 存储每个点
    - vertices： [A, B, C, D...]
  - adjList: 存储每个点之间的连接关系
    - adjList: {
      A: [B, C],
      B: [A, C],
      C: [A, B, D],
      D: [C],
      ...
      }

#### 图的遍历方式

- 每一个节点有三种状态

  - 未发现： 尚未发现此节点
  - 已发现：发现其他节点连接到此，但未查找次节点全部节点的连接
  - 已探索：已经发现次节点连接的全部节点

- 广度优先（队列）：优先遍历图的横向
  - 发现未发现节点后，放在队列中，等待查找，并且标志为已发现
  - 在队列中拿出已发现节点开始探索全部节点，并且跳过已发现节点
  - 遍历完此节点后，将此节点标志为已探索
  - 开始在队列中探索下一节点
- 深度优先（递归思想）：优先遍历图的纵向

  - 从某一节点开始查找，并且将自己标记为已发现
  - 从此节点继续探索其全部节点，并且跳过已发现节点
  - 遍历完此节点后，将此节点标记为已探索
  - 递归返回，继续探索下一路径的最深节点

- 最短路径问题
  - 记录 d（distance）: 其他位置距离 A 的距离 {A: 0, B; 1, C: 1, D: 2...}
    - 每次探索新点后(如 E), 将盖点距离(d['E'])设为回溯点(B)的距离加 1
    - d['E'] = d['B'] + 1
  - 回溯路径 pred：[A: null, B: 'A', E: 'B', F: 'B']
    - 每次探索新点后(如 E)，设置回溯点（B） pred['E'] = 'B'
